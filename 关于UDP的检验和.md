# 关于UDP的检验和计算(附代码) #

在下午的学习过程中<https://www.cnblogs.com/roccoshi/p/13032356.html> 有一张图讲述了UDP的校验方法, 如下:

![](E:\Documents\MyBlog\contents\rocco---计网\关于UDP的检验和\1.jpg)

老师只粗略的讲述了检验过程, 并没有讲计算方法, **检验和** 这玩意之前也多次提到过了, 每次都没有自己算过, 刚好借此机会详细了解记录一下



## 反码求和 ##

检验和主要是基于反码求和:

>反码求和运算：两个数进行二进制反码求和的运算很简单。它的规则是从低位到高位逐列进行计算。0和0相加是0，0和1相加是1，1和1相加是0，但要产生一个进位1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加1。

之前在操作检验和的过程中, 我一直有一个误解, 那就是计算时都把数据当成源码, 取反再进行上述规则的运算

但其实不是这样的, 数据本身就以"反码"形式存在, 直接按此规则计算即可.

简单来说, 对于图中的检验和计算过程, 就是这样的:

**把数据视为无符号16位整数相加， 如果产生了进位，则需要额外加1**

![](E:\Documents\MyBlog\contents\rocco---计网\关于UDP的检验和\2.jpg)



此处需要注意的是: 任何两个数进行反码求和产生进位, 将进位去除额外加一后不会产生新的进位了. 这里可以自行验证:

```
1111+1111=1111
```



## python代码计算 ##

经过上面的分析, 直接给出计算图中检验和的python代码: 

```python
import array

def checksum(data):
	s = 0
	for i in data:
		s += i
		s = (s & 0xffff) + (s >> 16) # 取前16位,然后将17位(进位的值加到第一位上)
	return (~s & 0xffff)


if __name__ == '__main__':
	data = [0b1001100100010011,0b0000100001101000,0b1010101100000011,0b0000111000001011,
			0b0000000000010001,0b0000000000001111,0b0000010000111111,0b0000000000001101,
			0b0000000000001111,0b0000000000000000,0b0101010001000101,0b0101001101010100,
			0b0100100101001110,0b0100011100000000]
	check = checksum(data) # 检验和的值
	data[9] = eval(bin(check)) # 将检验和对应的地方改成检验和
	print(bin(checksum(data)))	# 再进行反码求和,如果各位全为1,则说明检验通过
	if checksum(data)==0:
		print("yes")
```

得到的结果为:

```python
0b0110100100010010 # 得到的checksum
0b1111111111111111 # 加入checksum后的结果,全1表示检验通过了
yes
```





